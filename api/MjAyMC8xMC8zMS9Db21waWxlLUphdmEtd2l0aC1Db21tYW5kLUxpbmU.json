{"title":"Compile & Compact Java with Command Line","date":"2020-10-31T08:01:51.000Z","date_formatted":{"ll":"Oct 31, 2020","L":"10/31/2020","MM-DD":"10-31"},"link":"2020/10/31/Compile-Java-with-Command-Line","comments":true,"tags":["Java","tips"],"categories":["Programming"],"updated":"2020-10-31T08:01:51.999Z","content":"<p>As a modern IDE like IDEA or Eclipse is capable to do excellent work for us, our knowledge of command line operations may become rusty. You may remember <code>javac</code> is the compiler that translates <code>.java</code> to <code>.class</code>. And <code>java</code> command reads the <code>.class</code> files and executes them in JVM. You may also pack your codes into executable JARs or libraries for others to use, and meanwhile we download and import JARs from others. However, these are way too fundamental. In real-world cases, you may encounter situations such as slightly adjusting others completed code, or making improvements on a decompiled class file. It is necessary to learn more. </p>\n<h2 id=\"compiling-java-in-command-line\">Compiling Java in Command Line<a href=\"#compiling-java-in-command-line\" title=\"Compiling Java in Command Line\"></a></h2><h3 id=\"compiling-multiple-files-at-a-time\">Compiling Multiple Files at a Time<a href=\"#compiling-multiple-files-at-a-time\" title=\"Compiling Multiple Files at a Time\"></a></h3><p>Imagine that there are two classes:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Hello World\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(String name)</span></span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span></span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;&#125;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span></span>&#123;<span class=\"keyword\">this</span>.name=name;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>They are saved as <code>Main.java</code> and <code>Person.java</code> under /home directory.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">home</span><br><span class=\"line\">├── Main.java</span><br><span class=\"line\">└── Person.java</span><br></pre></td></tr></table></figure>\n\n<p>How to compile these two classes at the same time?</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javac /home/*.java</span><br></pre></td></tr></table></figure>\n\n<p>Running main class:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java /home/Main</span><br></pre></td></tr></table></figure>\n\n<p>What if we want to compile these two classes and put them in a specified directory? We can use <code>-d</code> parameter to specify where to place generated class files.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javac -d /home/target /home/*.java</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target</span><br><span class=\"line\">├── Main.class</span><br><span class=\"line\">└── Person.class</span><br></pre></td></tr></table></figure>\n\n<p><strong>Note that before Java 9, the target directory must be created beforehand</strong>. Otherwise <code>javac</code> will prompt you with a <code>directory not found</code> error. Java 9 onwards, <code>javac</code> creates the output directory if it doesn’t exist. </p>\n<p>Running the main class requires an extra parameter <code>-cp</code> or <code>-classpath</code> that specifies class search path of directories and zip/jar files. </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -cp /home/target Main</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"compiling-classes-that-have-relationships\">Compiling Classes that Have Relationships<a href=\"#compiling-classes-that-have-relationships\" title=\"Compiling Classes that Have Relationships\"></a></h3><p>Now consider we edit the content of <code>Main.java</code>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Person person = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"John\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Hello World, \"</span>+person.getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>It is rather obvious that the class won’t be compiled successfully, because class Person is an external file, and you haven’t imported the class yet. </p>\n<p>Of course,barely adding an extra <code>import Person</code> is also definitely not the right solution. The main reason is that they are not really under the same package. Since these two classes are already under the same directory, inserting <code>package test;</code> at the head of both files would suffice. Subsequently, this causes a side effect: When you run <code>javac -d /home/target /home/*.java</code>, it will create an extra directory <code>test</code> where two compiled classes lie in.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target</span><br><span class=\"line\">└── test</span><br><span class=\"line\">    ├── Main.class</span><br><span class=\"line\">    └── Person.class</span><br></pre></td></tr></table></figure>\n\n<p>Also pay attention when running the main class. Package name should be linked by <code>.</code> instead of directory delimiter <code>/</code>.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -cp /home/target test.Main</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"compiling-classes-that-import-external-libraries\">Compiling Classes that Import External Libraries<a href=\"#compiling-classes-that-import-external-libraries\" title=\"Compiling Classes that Import External Libraries\"></a></h3><p>More often than not, we may introduce compacted jar libraries in coding to save the time from creating duplicated wheels. Here consider our <code>Main.java</code> introduces Person class from an external package.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.michael.basics.Person;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String URL = <span class=\"string\">\"jdbc:mysql://localhost:3306/test\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String USERNAME = <span class=\"string\">\"root\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String PASSWORD = <span class=\"string\">\"mysql\"</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">        Person person </span>= <span class=\"keyword\">new</span> Person(<span class=\"string\">\"John\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Hello World, \"</span>+person.getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>And the directory structure looks like this:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">home</span><br><span class=\"line\">└── project</span><br><span class=\"line\">\t├── <span class=\"built_in\">test</span></span><br><span class=\"line\">\t|   └── Main.java</span><br><span class=\"line\">\t└── lib</span><br><span class=\"line\">\t\t└── michael-commons.jar</span><br></pre></td></tr></table></figure>\n\n<p>It’s natural to infer that <code>michael-commons.jar</code>  compacts class <code>com.michael.basics.Person</code> class. You might compile and run Main class using command below:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javac -cp /home/project/lib/*.jar /home/project/<span class=\"built_in\">test</span>/*.java</span><br></pre></td></tr></table></figure>\n\n<p>You don’t have to link the library when you’re running the main class.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -cp /home/project test.Main</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"compacting-compiled-classes-to-jar\">Compacting Compiled Classes to Jar<a href=\"#compacting-compiled-classes-to-jar\" title=\"Compacting Compiled Classes to Jar\"></a></h2><p>Packaging tools like Maven and Gradle help us to compact the compiled classes to <code>jar</code> files. At the same time, they provides dependency management functionalities. People tend to use them due to the  high usability, but easily forget that <code>jar</code> command itself can do the packaging as well.</p>\n<p>Take the files we have written above(<code>Main.class</code> and <code>Person.class</code>) for demonstrations.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jar -cf Main.jar -C /home/target/ <span class=\"built_in\">test</span>/*.class</span><br></pre></td></tr></table></figure>\n\n<p><code>-c</code> or <code>--create</code>  parameters indicates the command is to create a new jar file.</p>\n<p><code>-f</code> or <code>--file</code> specifies the name of the new jar file.</p>\n<p><code>-C</code> changes to the specified directory and includes all the files under this directory.</p>\n<p>Some other useful parameters:</p>\n<p><code>-v</code> or <code>--verbose</code> prints out the details during the packaging process.</p>\n<p>Despite the fact that a new JAR file is generated at present directory, you may still get an error when running command</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -jar Main.jar</span><br></pre></td></tr></table></figure>\n\n<p>This is mainly because though <code>Manifest.MF</code> is generated automatically, no main class attribute is specified. Most likely the error message would be:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Main.jar has no main manifest attribute.</span><br></pre></td></tr></table></figure>\n\n<p><code>jar</code> provides an useful parameter for users to specifies main class.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jar -cfe Main.jar test.Main -C /home/target <span class=\"built_in\">test</span>/*.class</span><br></pre></td></tr></table></figure>\n\n<p>Or, we can write a <code>Manifest.mf</code> file ourselves to avoid the long lines of parameters(whereas packaging tools generate a perfect one for us. That’s what the tools are for, right?)</p>\n<p>The format of a <code>Manifest.mf</code> looks very much like this:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Manifest-Version: 1.0</span><br><span class=\"line\">Created-By: 11.0.9 (Oracle Corporation)</span><br><span class=\"line\">Main-Class: test.Main</span><br><span class=\"line\">Class-Path:</span><br></pre></td></tr></table></figure>\n\n<p>All attributes are listed in key-value pattern, very similar to <code>YAML</code>. There’s <strong>always a single space between the colon and the attribute value. Also, leave a single blank line at the tail of the file.</strong> </p>\n<ol><li>The first two lines of the file is always about the Manifest version and the JDK version.</li>\n<li>Main-Class is required as long as you want your JAR to be executable. JARs as libraries or frameworks may not necessary to claim this attribute.</li>\n<li>If your classes introduces third-party libraries or JARs, you may need to specifies <code>Class-Path</code> attribute. Note that each JAR is delimited by <strong>a semicolon and a space after</strong>. </li>\n</ol><p>If we want to generate a JAR that reads the <code>Manifest.mf</code> written by ourselves instead of automatically generated one, use the following command will do:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jar -cfm Main.jar Manifest.mf -C /home/target /<span class=\"built_in\">test</span>/*.class</span><br></pre></td></tr></table></figure>\n\n<p>Beware that if you type in the command below, without passing <code>-C</code> parameter but the directory path instead:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jar -cfm Main.jar Manifest.mf /home/target/<span class=\"built_in\">test</span>/*.class</span><br></pre></td></tr></table></figure>\n\n<p>jar will pack <code>home/target</code> directory in the compacted file as well. It may lead to further problems when you try to run the generated JAR. Since the package name of <code>Main.class</code> is <code>test</code>, you run it with command <code>java test.Main</code>. Try running <code>java -jar Main.jar</code> when nesting <code>test</code> directory in <code>home/target</code>, you may receive an error: </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error: Cannot find or load main class test.Main</span><br><span class=\"line\">Cause: java.lang.ClassNotFoundException: test.Hello</span><br></pre></td></tr></table></figure>\n\n<p>Thus it is necessary to make sure you include the correct package or directory into a JAR.</p>\n","next":{"title":"Channel in Kotlin & Golang","link":"2020/10/16/Channel-in-Kotlin-Golang"},"plink":"https://git.michaelsblog.top/2020/10/31/Compile-Java-with-Command-Line/","toc":[{"id":"compiling-java-in-command-line","title":"Compiling Java in Command Line","index":"1","children":[{"id":"compiling-multiple-files-at-a-time","title":"Compiling Multiple Files at a Time","index":"1.1"},{"id":"compiling-classes-that-have-relationships","title":"Compiling Classes that Have Relationships","index":"1.2"},{"id":"compiling-classes-that-import-external-libraries","title":"Compiling Classes that Import External Libraries","index":"1.3"}]},{"id":"compacting-compiled-classes-to-jar","title":"Compacting Compiled Classes to Jar","index":"2"}]}