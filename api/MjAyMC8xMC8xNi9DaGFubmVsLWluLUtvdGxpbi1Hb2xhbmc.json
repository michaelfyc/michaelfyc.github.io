{"title":"Channel in Kotlin & Golang","date":"2020-10-16T08:19:17.000Z","date_formatted":{"ll":"Oct 16, 2020","L":"10/16/2020","MM-DD":"10-16"},"link":"2020/10/16/Channel-in-Kotlin-Golang","comments":true,"tags":["Golang","Kotlin","coroutine"],"categories":["Programming"],"updated":"2020-10-16T08:19:17.046Z","content":"<h2 id=\"concept\">Concept<a href=\"#concept\" title=\"Concept\"></a></h2><p><code>Channel</code> is designed to transfer single value between coroutines. In multi-thread environment, thread communicates through sharing memory. Coroutine uses channel to avoid the endless error caused by memory-sharing.</p>\n<p>Channel is implemented by blocking queue. Thus, specifying type is necessary when initializing.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> channel = Channel&lt;<span class=\"built_in\">Int</span>&gt;()</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">channel := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"transferring-values\">Transferring Values<a href=\"#transferring-values\" title=\"Transferring Values\"></a></h2><p>In Kotlin, transferring is done through methods <code>send</code> and <code>receieve</code> . In Go, who boasts of its simplicity, uses arrow expression:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">channel&lt;- <span class=\"number\">1</span> <span class=\"comment\">//send 1 to channel</span></span><br><span class=\"line\">value &lt;-channel <span class=\"comment\">//fetch value from channel</span></span><br><span class=\"line\">fmt.Println(value)</span><br></pre></td></tr></table></figure>\n\n<p> A channel can be closed to indicate that no more elements are coming. On the receiver side it is convenient to use a regular <code>for</code> loop to receive elements from the channel.</p>\n<p>Closing channel:</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">channel.close()</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">close</span>(channel)</span><br></pre></td></tr></table></figure>\n\n<p>Using for loop to receive channel messages:                                                                            </p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(chan <span class=\"keyword\">in</span> channel)&#123;</span><br><span class=\"line\">    println(chan)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> ch:=<span class=\"keyword\">range</span>(channel)&#123;</span><br><span class=\"line\">    fmt.Println(ch)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Channel</code> follows <code>FIFO</code> principle since it’s a queue under the hood. You can even call <code>offer</code> and <code>poll</code> method in Kotlin.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(i <span class=\"keyword\">in</span> <span class=\"number\">1</span>..<span class=\"number\">3</span>)&#123;</span><br><span class=\"line\">    channel.send(i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(chan <span class=\"keyword\">in</span> channel)&#123;</span><br><span class=\"line\">    print(chan)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">channel.close()</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">time.Sleep(<span class=\"number\">5000</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i:=<span class=\"number\">0</span>;i&lt;<span class=\"number\">3</span>;i++&#123;</span><br><span class=\"line\">    ch&lt;- i</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> c := <span class=\"keyword\">range</span>(ch)&#123;</span><br><span class=\"line\">    fmt.Print(c)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">close</span>(c)</span><br></pre></td></tr></table></figure>\n\n<p>Result:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">123</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"channel-withwithout-buffer\">Channel with/without Buffer<a href=\"#channel-withwithout-buffer\" title=\"Channel with/without Buffer\"></a></h2><p>Initializing a channel with specified size of buffer is easy.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> channel = Channel&lt;<span class=\"built_in\">Int</span>&gt;(<span class=\"number\">5</span>) <span class=\"comment\">//buffer size:8*sizeof(Int)</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>,<span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure>\n\n<p>For a channel without buffer A sender will keep waiting unless a receiver is ready. This allows the coroutines to communicate synchronously without explicitly writing lock. </p>\n<p>With buffer, channel communication is asynchronous and non-blocking. Message producer sends messages to channel buffer and turns its back to do something else. Receiver, on the other hand, fetches messages from channel’s buffer.  The whole process is unblocking, unless all buffers are occupied(the sender will be waiting until a receiver comes).</p>\n<h3 id=\"dont-forget-these\"><strong>Don’t forget these!</strong><a href=\"#dont-forget-these\" title=\"Don’t forget these!\"></a></h3><ol><li><p><code>send(&lt;T&gt; t T)</code> and <code>receive()</code> are suspend methods in Kotlin. So are <code>ch&lt;-</code> and <code>&lt;-ch</code>. They should be used in a coroutine but not the main thread.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> channel = Channel&lt;<span class=\"built_in\">Int</span>&gt;()</span><br><span class=\"line\">    channel.send(<span class=\"number\">1</span>)</span><br><span class=\"line\">    println(channel.receive())</span><br><span class=\"line\">    <span class=\"comment\">// Compilation error:</span></span><br><span class=\"line\">    <span class=\"comment\">// Suspend function 'send' should be called only from a coroutine or another suspend function</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br><span class=\"line\">    ch&lt;<span class=\"number\">-10</span></span><br><span class=\"line\">    fmt.Println(&lt;-ch)</span><br><span class=\"line\">    <span class=\"comment\">// Runtime error:</span></span><br><span class=\"line\">    <span class=\"comment\">// Fatal error: all goroutines are asleep - deadlock</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Always remember, <strong>program ends when the main function ends.</strong> The solution could be sleeping for a while before the program ends. As for Kotlin, where <code>send</code> and <code>receive</code> are suspend functions are only available in a coroutine, it is recommended to use <code>runBlocking</code> as a coroutine context.</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>,<span class=\"number\">10</span>)</span><br><span class=\"line\">    ch&lt;<span class=\"number\">-10</span></span><br><span class=\"line\">    fmt.Println(&lt;-ch)</span><br><span class=\"line\">    time.Sleep(<span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>=runBlocking&lt;<span class=\"built_in\">Unit</span>&gt;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> channel = Channel&lt;<span class=\"built_in\">Int</span>&gt;(<span class=\"number\">10</span>)</span><br><span class=\"line\">    channel.send(<span class=\"number\">10</span>)</span><br><span class=\"line\">    println(channel.receive())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>Close the channel promptly</strong>:</p>\n<p><code>for</code> loop reading channel’s messages is convenient still, but it’s also blocking if channel is not closed at the right time.</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i:= <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i= i + <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t\tch&lt;- i</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">time.Sleep(<span class=\"number\">1</span>*time.HOUR)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i:=<span class=\"keyword\">range</span> ch&#123;</span><br><span class=\"line\">    fmt.Println(i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>This part of code would keep waiting for an hour after 0-9 are printed. In fact, channel should be closed after sending messages. </p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">runBlocking&#123;</span><br><span class=\"line\">    repeat(<span class=\"number\">10</span>)&#123;</span><br><span class=\"line\">        channel.send(it)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i <span class=\"keyword\">in</span> channel)&#123;</span><br><span class=\"line\">        println(i)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>As for Kotlin, the channel won’t stop listening even though 0-9 is outputted. </p>\n<p><strong>Close the channel if the work is done.</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i = i + <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\tch&lt;- i</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">    \t<span class=\"built_in\">close</span>(ch)</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">time.Sleep(<span class=\"number\">1</span>*time.HOUR)</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repeat(<span class=\"number\">10</span>)&#123;</span><br><span class=\"line\">    channel.send(it)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">channel.close()</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>Don’t worry, because we can still read channel messages even though it’s closed. (You can’t send anything if the channel is closed, of course.)</p>\n</li>\n</ol><h2 id=\"select\">Select<a href=\"#select\" title=\"Select\"></a></h2><blockquote>\n<p>Before kotlin-coroutines-core version 1.4, <code>select</code> is an experimental feature. Some methods are even marked deprecated in some versions of 1.3. </p>\n</blockquote>\n<p>   <code>Select</code> is used where coroutines competes.</p>\n   <figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ch1 := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>,<span class=\"number\">5</span>)</span><br><span class=\"line\">ch2 := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">string</span>,<span class=\"number\">5</span>)</span><br><span class=\"line\">ch1 &lt;- <span class=\"number\">9</span></span><br><span class=\"line\">ch2 &lt;- <span class=\"string\">\"Channel 2\"</span></span><br><span class=\"line\"><span class=\"keyword\">select</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> value := &lt;-ch1:</span><br><span class=\"line\">    \tfmt.Println(<span class=\"string\">\"ch1 \"</span>,value)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> value := &lt;-ch2:</span><br><span class=\"line\">    \tfmt.Println(<span class=\"string\">\"ch2 \"</span>,value)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n   <figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> ch1 = Channel&lt;<span class=\"built_in\">Int</span>&gt;(<span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> ch2 = Channel&lt;String&gt;(<span class=\"number\">5</span>)</span><br><span class=\"line\">ch1.send(<span class=\"number\">9</span>)</span><br><span class=\"line\">ch2.send(<span class=\"string\">\"Channel 2\"</span>)</span><br><span class=\"line\">select&lt;<span class=\"built_in\">Unit</span>&gt;&#123;</span><br><span class=\"line\">    ch1.onReceive&#123;value-&gt; println(<span class=\"string\">\"ch1 <span class=\"variable\">$value</span>\"</span>)&#125;</span><br><span class=\"line\">    ch2.onReceive&#123;value-&gt; println(<span class=\"string\">\"ch2 <span class=\"variable\">$vale</span>\"</span>)&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n","prev":{"title":"Compile & Compact Java with Command Line","link":"2020/10/31/Compile-Java-with-Command-Line"},"next":{"title":"Kotlin Delegation & Examples","link":"2020/10/10/Kotlin-Delegation-Examples"},"plink":"https://git.michaelsblog.top/2020/10/16/Channel-in-Kotlin-Golang/","toc":[{"id":"concept","title":"Concept","index":"1"},{"id":"transferring-values","title":"Transferring Values","index":"2"},{"id":"channel-withwithout-buffer","title":"Channel with&#x2F;without Buffer","index":"3","children":[{"id":"dont-forget-these","title":"Don’t forget these!","index":"3.1"}]},{"id":"select","title":"Select","index":"4"}]}