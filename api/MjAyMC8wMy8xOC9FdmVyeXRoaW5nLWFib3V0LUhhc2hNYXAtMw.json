{"title":"Everything about HashMap(3)","date":"2020-03-18T11:40:27.000Z","date_formatted":{"ll":"Mar 18, 2020","L":"03/18/2020","MM-DD":"03-18"},"thumbnail":"https://img.cdn.n3ko.co/lsky/2020/03/17/4094fa0d49806.png?x-oss-process=image/auto-orient,1/quality,q_70/sharpen,200/format,webp","link":"2020/03/18/Everything-about-HashMap-3","comments":true,"tags":["Java"],"categories":["Programming"],"updated":"2020-03-19T13:14:01.752Z","content":"<h2 id=\"differences-between-jdk-17-amp-18\">Differences between JDK 1.7 &amp; 1.8<a href=\"#differences-between-jdk-17-amp-18\" title=\"Differences between JDK 1.7 &amp; 1.8\"></a></h2><ol><li><p>Hash method in 1.7:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    h ^= (h &gt;&gt;&gt; <span class=\"number\">20</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">12</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> h ^ (h &gt;&gt;&gt; <span class=\"number\">7</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">4</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>HashMap’s data structure in 1.7 is the combination of list and array. JDK 1.8 introduces red-black tree.</p>\n</li>\n<li><p>In JDK 1.7, if hash collides, the new node is inserted to the head, while in JDK 1.8, the new node is inserted to the end of the list.</p>\n</li>\n<li><p>In JDK 1.7, the program will check if it needs to enlarge the capacity before the node is inserted. In JDK 1.8, the check happens after the node is inserted.</p>\n</li>\n<li><p>Elements will be re-hashed and re-indexed after capacity resize in JDK 1.7. In JDK 1.8, the index of the elements does not change if the capacity changes.</p>\n</li>\n</ol><h2 id=\"why-the-optimization\">Why the Optimization?<a href=\"#why-the-optimization\" title=\"Why the Optimization?\"></a></h2><ol><li><p>Maybe the developers of JDK think shifting and xoring four times is unnecessary.</p>\n</li>\n<li><p>Avoid the list being too long if hash collision happens. Decrease the time complexity to O(logn).</p>\n</li>\n<li><p>The list may turn into a circle under multi-thread environment. </p>\n</li>\n<li><p>What Java 1.7 does when resize:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>((size &gt;= threshold) &amp;&amp; (<span class=\"keyword\">null</span> != table[bucketIndex])) &#123;</span><br><span class=\"line\">    resize(<span class=\"number\">2</span>*table.length);</span><br><span class=\"line\">    hash = (<span class=\"keyword\">null</span> == key) ? hash(key) : <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>While in Java 1.8, <code>resize()</code> accepts no parameter. </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (oldCap &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class=\"line\">                threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> oldTab;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((newCap = oldCap &lt;&lt; <span class=\"number\">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class=\"line\">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class=\"line\">                newThr = oldThr &lt;&lt; <span class=\"number\">1</span>; <span class=\"comment\">// double threshold</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldThr &gt; <span class=\"number\">0</span>) <span class=\"comment\">// initial capacity was placed in threshold</span></span><br><span class=\"line\">            newCap = oldThr;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;               <span class=\"comment\">// zero initial threshold signifies using defaults</span></span><br><span class=\"line\">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class=\"line\">            newThr = (<span class=\"keyword\">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n\n<p>The trick is, since enlarge equals double, and the capacity of array is the multiples of 2, all we need to do is to see what the most significant bit of the new hash result is.</p>\n<p>For instance, the old hash code of element is 00010011, the current capacity is 16, the index, by <code>h&amp;(n-1)</code>, should be 11<sub>2</sub>, i.e., 3<sub>10</sub>.</p>\n<p>After the capacity enlarges to 32, the index should now be 10011<sub>2</sub>, or 19<sub>10</sub>. </p>\n<p>If the hash code of the element is 00101010, the current capacity 16, the index should be 1010<sub>2</sub>, or 10<sub>10</sub>. After resizing to 32, the index is still 1010<sub>2</sub>, which means the element does need to move.</p>\n<p>In fact, after resizing, the element index either stays the same, or adds 16. </p>\n<h2 id=\"is-hashmap-thread-safeif-not-whats-the-workaround\">Is HashMap Thread-Safe?If not, What’s the Workaround?<a href=\"#is-hashmap-thread-safeif-not-whats-the-workaround\" title=\"Is HashMap Thread-Safe?If not, What’s the Workaround?\"></a></h2><p>Nope. There are HashTable, Collections.synchronizedMap and ConcurrentHashMap. HashTable is just like HashMap, but all its methods are synchronized. Collections.synchronizedMap accepts a Map object and returns a SynchronizedMap object, in which defined an object lock. ConcurrentHashMap implements multiple segment lock.</p>\n<h2 id=\"why-the-treeify-threshold-8-but-untreeify-threshold-6\">Why the Treeify Threshold 8 but Untreeify Threshold 6?<a href=\"#why-the-treeify-threshold-8-but-untreeify-threshold-6\" title=\"Why the Treeify Threshold 8 but Untreeify Threshold 6?\"></a></h2><p>According calculations, the probability of hash collides 8 times is nearly 6 of a million. The probability is small enough. But if the untreeify threshold is around 8, list and red-black tree may transfer too frequently. Therefore it is set 6.</p>\n</li>\n</ol>","prev":{"title":"Everything about HashMap Extra","link":"2020/03/20/Everything-about-HashMap-Extra"},"next":{"title":"Everything about HashMap(2)","link":"2020/03/18/Everything-about-HashMap-2"},"plink":"https://git.michaelsblog.top/2020/03/18/Everything-about-HashMap-3/","toc":[{"id":"differences-between-jdk-17-amp-18","title":"Differences between JDK 1.7 &amp; 1.8","index":"1"},{"id":"why-the-optimization","title":"Why the Optimization?","index":"2"},{"id":"is-hashmap-thread-safeif-not-whats-the-workaround","title":"Is HashMap Thread-Safe?If not, What’s the Workaround?","index":"3"},{"id":"why-the-treeify-threshold-8-but-untreeify-threshold-6","title":"Why the Treeify Threshold 8 but Untreeify Threshold 6?","index":"4"}]}