{"title":"Skip List","date":"2020-03-07T13:55:58.000Z","date_formatted":{"ll":"Mar 7, 2020","L":"03/07/2020","MM-DD":"03-07"},"link":"2020/03/07/sk-1","tags":["data structure"],"categories":["Programming"],"updated":"2020-03-14T14:29:11.514Z","content":"<h2 id=\"why-skip-list\">Why Skip List<a href=\"#why-skip-list\" title=\"Why Skip List\"></a></h2><p>It is more often to see implementation of <code>ArrayList</code>(singly linked list) and <code>LinkedList</code>(doubly linked list) in our code. </p>\n<h3 id=\"arraylist\">ArrayList<a href=\"#arraylist\" title=\"ArrayList\"></a></h3><p><strong>Advantage</strong>:</p>\n<ol><li><p>(compared to array) Easy insertions and deletions, unfixed size, expandable. </p>\n</li>\n<li><p>Less expensive and more efficient in storing data in memory.</p>\n</li>\n</ol><p><strong>Disadvantage</strong>:</p>\n<ol><li>(Compared to array)Require more space for pointers.</li>\n<li>(Compared to  array) Need more time to access a certain element.</li>\n<li>Cannot traverse it from last but only from the beginning. </li>\n</ol><h3 id=\"linkedlist\">LinkedList<a href=\"#linkedlist\" title=\"LinkedList\"></a></h3><p><strong>Advantage</strong>:</p>\n<ol><li>Can traverse in both direction, from starting to end or from end to starting.</li>\n<li>Easy reversion.</li>\n<li>If we are at a node, we can go at any node.</li>\n</ol><p><strong>Disadvantage</strong>:</p>\n<ol><li>Requires extra space for pointer pointed to the previous node.</li>\n<li>Take more time in insertion and deletion.</li>\n</ol><p>The worst case search time for a sorted linked list is O(n) as we can only linearly traverse the list and cannot skip nodes while searching. However, with <strong>Skip List</strong>, time-complexity can be reduced to O(logn).  You can find it in the source code of MySQL and Redis.</p>\n<h2 id=\"how-skip-list-works\">How Skip List Works?<a href=\"#how-skip-list-works\" title=\"How Skip List Works?\"></a></h2><p>Take an original list for instance.</p>\n<p><img src=\"https://img.cdn.n3ko.co/lsky/2020/03/07/8ea9cfc46e8aa.png?x-oss-process=image/auto-orient,1/quality,q_70/sharpen,200/format,webp\" class=\"φcy\" alt=\"1\"></p>\n<p>Provided that we wanted to search node with data 55. We’ll have to traverse the list from the first node using for loops. Let alone -INF, we have to access 8 nodes in total. How can we access less nodes? The idea is simple. We create multiple layers so that we can skip some nodes.</p>\n<p><img src=\"https://img.cdn.n3ko.co/lsky/2020/03/07/f6b422be114d2.png?x-oss-process=image/auto-orient,1/quality,q_70/sharpen,200/format,webp\" class=\"φcy\" alt=\"2\"></p>\n<p>As is shown above, we need to access 4 nodes in L2 when we are looking for 55. In the worse scenario when the wanted node is 46, barely 5 nodes are accessed: First try searching 46 in L2. Find 55 after visiting 4 nodes and since the linked list is sorted, 46 is on the right of node 55. However, there is no 46 on L2. Thus we return back to node 37, go to L2 and search for 46. Fortunately, 46 is next to 37. And hence it took 5 steps in total.</p>\n<p>Of course, we can further optimize the procedure. With the previous instance, it easily comes to our head:</p>\n<p><img src=\"https://img.cdn.n3ko.co/lsky/2020/03/07/c629c70436028.png?x-oss-process=image/auto-orient,1/quality,q_70/sharpen,200/format,webp\" class=\"φcy\" alt=\"3\"></p>\n<p>Now, only 2 nodes are necessary if searching for 55. Element 46 is as time-consuming as previous one, 5 steps. First takes 2 steps to 55 on L3, then back to 21, and dive to L2. Another 2 steps to 55, back to 37, and drop to 37 on L1. Finally, take one step right, find 46. </p>\n<p>Similarly, the final optimization of skip list should look like this:</p>\n<p><img src=\"https://img.cdn.n3ko.co/lsky/2020/03/07/05eb636ed710f.png?x-oss-process=image/auto-orient,1/quality,q_70/sharpen,200/format,webp\" class=\"φcy\" alt=\"4\"></p>\n<p>Now searching for node 46 takes 6 steps, one extra step on L4. From the listed procedure, we can see that what skip list does really resembles that of a balance binary search tree. Insertion and deletion in a balance binary search tree are notoriously complicated, however. How can we implement a skip list and its insert/delete methods ourselves?</p>\n<h2 id=\"insertion-and-deletion\">Insertion and Deletion<a href=\"#insertion-and-deletion\" title=\"Insertion and Deletion\"></a></h2><h3 id=\"insertion\">Insertion<a href=\"#insertion\" title=\"Insertion\"></a></h3><p>Each layer of the ideal skip list has twice as many elements as its previous layer. Provided that element X was to be added to the list.  The prerequisite is obvious: X must be on Layer 1. Should we put X on Layer 2? If it’s hard to decide, why not toss a coin? Put it on if head’s up. The probability is 50%. Should we put X on L3? Toss the coin again! How about L4? Toss the coin! After several easy  calculations, the probability of element X inserting into Layer N should be the Nth power of 0.5. </p>\n<p>Here’s an example for better understanding.</p>\n<p> The begin state starts with no elements.</p>\n<p><img src=\"https://img.cdn.n3ko.co/lsky/2020/03/07/54f5a258c4654.png?x-oss-process=image/auto-orient,1/quality,q_70/sharpen,200/format,webp\" class=\"φcy\" alt=\"5\"></p>\n<p>Provided that we want to insert element 2 into the list. Add 2 to Layer 1 first.</p>\n<p><img src=\"https://img.cdn.n3ko.co/lsky/2020/03/07/0d88cf3567a00.png?x-oss-process=image/auto-orient,1/quality,q_70/sharpen,200/format,webp\" class=\"φcy\" alt=\"6\"></p>\n<p>Then we toss a coin. Head up, so add it to Layer 2.</p>\n<p><img src=\"https://img.cdn.n3ko.co/lsky/2020/03/07/8b644990e49c3.png?x-oss-process=image/auto-orient,1/quality,q_70/sharpen,200/format,webp\" class=\"φcy\" alt=\"7\"></p>\n<p>Toss the coin again. Tail up. Stop here and this should be what the skip list now look like. Now insert 33 to the list. Put it into Layer 1. It should be on the right of element 2 as it’s greater than 2. </p>\n<p><img src=\"https://img.cdn.n3ko.co/lsky/2020/03/07/b19858c0943cf.png?x-oss-process=image/auto-orient,1/quality,q_70/sharpen,200/format,webp\" class=\"φcy\" alt=\"8\"></p>\n<p>Toss the coin. Tail up. The insertion of 33 ends now.  Now the skip list is shown above.</p>\n<p>Add element 55 next. The procedure is completely the same. </p>\n<p><img src=\"https://img.cdn.n3ko.co/lsky/2020/03/07/a9b6e2f31a62a.png?x-oss-process=image/auto-orient,1/quality,q_70/sharpen,200/format,webp\" class=\"φcy\" alt=\"9\"></p>\n<p>Toss the coin. Get Head. Insert it to layer 2.</p>\n<p><img src=\"https://img.cdn.n3ko.co/lsky/2020/03/07/a3f8adfbc5af3.png?x-oss-process=image/auto-orient,1/quality,q_70/sharpen,200/format,webp\" class=\"φcy\" alt=\"10\"></p>\n<p>Toss the coin the second time. Horray! Another head up! Insert 55 to L3. </p>\n<p><img src=\"https://img.cdn.n3ko.co/lsky/2020/03/07/9599ff1abb3f7.png?x-oss-process=image/auto-orient,1/quality,q_70/sharpen,200/format,webp\" class=\"φcy\" alt=\"11\"></p>\n<p>Toss the coin the third time. Another head. Insert it to Layer 4.</p>\n<p><img src=\"https://img.cdn.n3ko.co/lsky/2020/03/07/d7d0f6fd2f2e6.png?x-oss-process=image/auto-orient,1/quality,q_70/sharpen,200/format,webp\" class=\"φcy\" alt=\"12\"></p>\n<p>Tail up, at last. Now the whole insertion stops.  The final skip list as shown above.</p>\n<p>As the images imply, the final skip list may not be a perfect one.  Nevertheless, as the number of elements increase, the probability should gradually approach to log<sub>2</sub>n. Detailed proof is left <a href=\"[https://www.ics.uci.edu/~pattis/ICS-23/lectures/notes/Skip%20Lists.pdf\">here</a>.</p>\n<h3 id=\"deletion\">Deletion<a href=\"#deletion\" title=\"Deletion\"></a></h3><p>Same as ordinary ArrayList. </p>\n","next":{"title":"Funny Features of JavaScript(3)","link":"2020/03/04/Funny-Features-of-JavaScript-3"},"plink":"https://git.michaelsblog.top/2020/03/07/sk-1/","toc":[{"id":"why-skip-list","title":"Why Skip List","index":"1","children":[{"id":"arraylist","title":"ArrayList","index":"1.1"},{"id":"linkedlist","title":"LinkedList","index":"1.2"}]},{"id":"how-skip-list-works","title":"How Skip List Works?","index":"2"},{"id":"insertion-and-deletion","title":"Insertion and Deletion","index":"3","children":[{"id":"insertion","title":"Insertion","index":"3.1"},{"id":"deletion","title":"Deletion","index":"3.2"}]}]}