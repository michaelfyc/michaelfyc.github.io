{"title":"Java:The Catch(1)","date":"2020-02-19T11:22:43.000Z","date_formatted":{"ll":"Feb 19, 2020","L":"02/19/2020","MM-DD":"02-19"},"thumbnail":"https://img.cdn.n3ko.co/lsky/2020/02/19/bf8ce73681b45.png?x-oss-process=image/auto-orient,1/quality,q_70/sharpen,200/format,webp","link":"2020/02/19/Java-The-Catch(1)","tags":["Java","tips"],"updated":"2020-02-19T12:01:55.349Z","content":"<p>Java as a part of the huge C family has a similar syntax to C&amp;C++. Nevertheless, Java has its own peculiarities.</p>\n<h2 id=\"basics\">Basics:<a href=\"#basics\" title=\"Basics:\"></a></h2><p>Unlike C, which has unsigned and signed data types, Java has barely 8 basic data types, or <strong>primitives</strong>: <code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>char</code>, <code>float</code>, <code>double</code>, <code>boolean</code>. All are signed. And note that, despite the fact that <strong>String</strong> is supported in <code>java.lang</code>, it is is not a basic data type.</p>\n<h5 id=\"1-data-types\">1. Data Types<a href=\"#1-data-types\" title=\"1. Data Types\"></a></h5><p>As learned in C, data types we can be upgraded automatically. Java supports the feature as well. </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main1</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">short</span> a=<span class=\"number\">127</span>;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> b=a+<span class=\"number\">2</span>;</span><br><span class=\"line\">       System.out.println(b);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Although <strong>Short.MAX_VALUE</strong> is 127, the main method runs perfectly without any compiling errors, because the addition is between two <strong>int</strong>, variable a upgraded.<br>Well, this is easy, you may think. Then how about this?</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main2</span></span>&#123;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> a=Integer.MAX_VALUE;</span><br><span class=\"line\">       <span class=\"keyword\">long</span> b=a+<span class=\"number\">2</span>;</span><br><span class=\"line\">       System.out.println(b);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>If you run the code, surprisingly, you will find out that the output is negative! It means the calculation isn’t made under a <strong>long</strong>, but still <strong>int</strong>! <mark> It’s because in Java,  <strong>Integer</strong> is set to be the default type of non-decimals(BTW, <strong>Double</strong> is set to be the default type of decimals)</mark>. In Main1, since 2 is already a default-integer, a+2 will overflow in int perspective.</p>\n<p>If you really want to obtain the right answer:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span></span>&#123;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> a=Integer.MAX_VALUE;</span><br><span class=\"line\">       <span class=\"keyword\">long</span> b=a+<span class=\"number\">2l</span>;</span><br><span class=\"line\">       System.out.println(b);</span><br><span class=\"line\">         <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         2147483649 </span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Incidentally,<strong>Compilation Error</strong> will raise if you try to write code like this:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span></span>&#123;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> a=Integer.MAX_VALUE;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> b=a+<span class=\"number\">2l</span>;<span class=\"comment\">//May loose accuracy</span></span><br><span class=\"line\">       System.out.println(b);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>And you will understand why the code below produces a infinite loop.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span></span>&#123;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">int</span> sum=<span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">byte</span> i=<span class=\"number\">0</span>;b&lt;<span class=\"number\">128</span>;b++)&#123;</span><br><span class=\"line\">          sum+=<span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">         System.out.println(sum);</span><br><span class=\"line\">         <span class=\"comment\">/* Wrong answer: 128</span></span><br><span class=\"line\"><span class=\"comment\">         *  Right answer: infinite loop: </span></span><br><span class=\"line\"><span class=\"comment\">         *  (If you tend to run the code, your IDE will end up crashed </span></span><br><span class=\"line\"><span class=\"comment\">         *  or throw a OOM exception.)</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"2-string\">2. String<a href=\"#2-string\" title=\"2. String\"></a></h5><h3 id=\"string\">String<a href=\"#string\" title=\"String\"></a></h3><p>String looks much more elegant than <code>char *</code> array in C and C++. It is natively supported in Java, and lots of useful methods are available. Yet, as compensation, some peculiarities exist. </p>\n<blockquote>\n<p>Rule Number 1: String is not a primitive. It is an immutable character array under the hood.</p>\n</blockquote>\n<p>We may create a String in several ways:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String a=<span class=\"keyword\">new</span> String(<span class=\"string\">\"Hello\"</span>);<span class=\"comment\">//through constructor</span></span><br><span class=\"line\">String b=<span class=\"string\">\"hello\"</span>;<span class=\"comment\">//through creating anonymous object</span></span><br><span class=\"line\">String c=<span class=\"string\">\"Hel\"</span>+<span class=\"string\">\"lo\"</span>;<span class=\"comment\">//through concatenating two strings</span></span><br></pre></td></tr></table></figure>\n\n<p>However, running  either <code>System.out.println(a==b)</code>or <code>System.out.println(a==c)</code>  gives you the answer <code>false</code>, but <code>System.out.println(b==c)</code> is <code>true</code>. Why is so?</p>\n<p>Well, before we go in deeper, you shall realize what operator <code>==</code> do.</p>\n<p><code>==</code> tests for reference equality (whether they are the same object). </p>\n<p>On the other hand, class Object offers a method <code>Object.equals()</code>. It tests for value equality (whether they are logically “equal”). It barely compares the hash code of two objects. </p>\n<p>Thus, we strongly recommend you to use <code>.equals()</code> to avoid being caught by the trap.</p>\n<p>So back to where we’re saying, why does the comparing result vary?</p>\n<p>Let’s take a closer look at these three ways of creating String. </p>\n<p><strong>Through Anonymous Object</strong>:</p>\n<p>​    Although it looks really like you’re just passing something included in “” to a variable, the whole process is actually instantiating an anonymous object. This is could be easily proved: No compilation error pop out when you call <code>&quot;Hello&quot;.equals()</code>, since <code>.equals()</code> could be only called by an instance of class Object and its subclasses.   </p>\n<p>In the end of the whole creating process, the String “Hello” is put into some part in heap called <strong>constant pool</strong>.  Constant pool serves like a cache. If JVM finds the needed String already in the constant pool, it will reuse the String instead of allocating new memory.  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String a=<span class=\"string\">\"Hello\"</span>;</span><br><span class=\"line\">String b=<span class=\"string\">\"Hello\"</span>;</span><br><span class=\"line\">System.out.println(a==b);<span class=\"comment\">//true,because both fetch from pool</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>Through Constructor:</strong></p>\n<p>​    As is easily seen, we’re <em>newing</em> a String, which means new block of memory in heap is allocated every time. In this case, the String will not be automatically stored into constant pool. </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String a=<span class=\"keyword\">new</span> String(<span class=\"string\">\"Hello\"</span>);</span><br><span class=\"line\">String b=<span class=\"keyword\">new</span> String(<span class=\"string\">\"Hello\"</span>);</span><br><span class=\"line\">System.out.println(a==b);<span class=\"comment\">//false, because referring to different part of memory</span></span><br></pre></td></tr></table></figure>\n\n<p>You can manually put the String into constant pool by calling <code>.intern()</code> method. </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String a=<span class=\"keyword\">new</span> String(<span class=\"string\">\"Hello\"</span>);</span><br><span class=\"line\">String b=<span class=\"string\">\"Hello\"</span>;</span><br><span class=\"line\">System.out.println(a==b);<span class=\"comment\">//false, because a is from heap and b is from pool</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String a=<span class=\"keyword\">new</span> String(<span class=\"string\">\"Hello\"</span>).intern();</span><br><span class=\"line\">String b=<span class=\"string\">\"Hello\"</span>;</span><br><span class=\"line\">System.out.println(a==b);<span class=\"comment\">//true, because both fetched from pool</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>Though Joining Two Strings:</strong></p>\n<p>​    There’s actually two kinds of joining. </p>\n<p>​    1.<code>String a=&quot;Hel&quot;+&quot;lo&quot;;</code></p>\n<p>​    2.<code>String temp=&quot;Hel&quot;;String b=temp+&quot;lo;&quot;</code></p>\n<p>For the former way, JVM joins “Hel” and “lo” before anonymous object is created. In the very end, “Hello” is put into constant pool.</p>\n<p>For the latter way, you will find both “Hel” and “lo” in the constant pool. </p>\n<p>Now you can explain the result below:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String a=<span class=\"string\">\"Hel\"</span>+<span class=\"string\">\"lo\"</span>;</span><br><span class=\"line\">String b=<span class=\"string\">\"Hello\"</span>;</span><br><span class=\"line\">System.out.println(a==b);<span class=\"comment\">//true, because both fetch from pool</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String a=<span class=\"string\">\"Hel\"</span>+<span class=\"string\">\"lo\"</span>;</span><br><span class=\"line\">String temp=<span class=\"string\">\"Hel\"</span>;</span><br><span class=\"line\">String b=temp+<span class=\"string\">\"lo\"</span>;</span><br><span class=\"line\">System.out.println(a==b);<span class=\"comment\">//false, because b can't be fetched directly from pool</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>Suggestions:</strong></p>\n<p><strong>If you need to see whether two strings have the same value, you will probably want to use <code>Objects.equals()</code>.</strong> Furthermore, it is more suggested to use <code>&quot;str&quot;.equals(variable);</code>  instead of <code>variable.equals(&quot;str&quot;);</code>, lest the variable is <code>null</code>. Using <code>compareTo</code> is also an alternative, though it might not be as readable as <code>equals</code> and need to write a bit more.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String a=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">...</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"Hello\"</span>.equals(a));<span class=\"comment\">//false</span></span><br><span class=\"line\">System.out.println(a.equals(<span class=\"string\">\"Hello\"</span>));<span class=\"comment\">//Throw NullPointerException, program stops</span></span><br></pre></td></tr></table></figure>\n","next":{"title":"Do-Math-With-Python","link":"2020/02/18/Do-Math-With-Python"},"plink":"http://yoursite.com/2020/02/19/Java-The-Catch(1)/","toc":[{"id":"basics","title":"Basics:","index":"1","children":[{"id":"string","title":"String","index":"1.1"}]}]}